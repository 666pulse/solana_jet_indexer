/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * ArithmeticError: 'failed to perform some math operation safely'
 *
 * @category Errors
 * @category generated
 */
export class ArithmeticErrorError extends Error {
  readonly code: number = 0x1770
  readonly name: string = 'ArithmeticError'
  constructor() {
    super('failed to perform some math operation safely')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ArithmeticErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new ArithmeticErrorError())
createErrorFromNameLookup.set(
  'ArithmeticError',
  () => new ArithmeticErrorError(),
)

/**
 * InvalidOracle: 'oracle account provided is not valid'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOracleError extends Error {
  readonly code: number = 0x1771
  readonly name: string = 'InvalidOracle'
  constructor() {
    super('oracle account provided is not valid')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOracleError)
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new InvalidOracleError())
createErrorFromNameLookup.set('InvalidOracle', () => new InvalidOracleError())

/**
 * NoFreeReserves: 'no free space left to add a new reserve in the market'
 *
 * @category Errors
 * @category generated
 */
export class NoFreeReservesError extends Error {
  readonly code: number = 0x1772
  readonly name: string = 'NoFreeReserves'
  constructor() {
    super('no free space left to add a new reserve in the market')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoFreeReservesError)
    }
  }
}

createErrorFromCodeLookup.set(0x1772, () => new NoFreeReservesError())
createErrorFromNameLookup.set('NoFreeReserves', () => new NoFreeReservesError())

/**
 * NoFreeObligation: 'no free space left to add the new loan or collateral in an obligation'
 *
 * @category Errors
 * @category generated
 */
export class NoFreeObligationError extends Error {
  readonly code: number = 0x1773
  readonly name: string = 'NoFreeObligation'
  constructor() {
    super(
      'no free space left to add the new loan or collateral in an obligation',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoFreeObligationError)
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new NoFreeObligationError())
createErrorFromNameLookup.set(
  'NoFreeObligation',
  () => new NoFreeObligationError(),
)

/**
 * UnregisteredPosition: 'the obligation account doesn't have any record of the loan or collateral account'
 *
 * @category Errors
 * @category generated
 */
export class UnregisteredPositionError extends Error {
  readonly code: number = 0x1774
  readonly name: string = 'UnregisteredPosition'
  constructor() {
    super(
      "the obligation account doesn't have any record of the loan or collateral account",
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnregisteredPositionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new UnregisteredPositionError())
createErrorFromNameLookup.set(
  'UnregisteredPosition',
  () => new UnregisteredPositionError(),
)

/**
 * InvalidOraclePrice: 'the oracle price account has an invalid price value'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOraclePriceError extends Error {
  readonly code: number = 0x1775
  readonly name: string = 'InvalidOraclePrice'
  constructor() {
    super('the oracle price account has an invalid price value')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOraclePriceError)
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new InvalidOraclePriceError())
createErrorFromNameLookup.set(
  'InvalidOraclePrice',
  () => new InvalidOraclePriceError(),
)

/**
 * InsufficientCollateral: 'there is not enough collateral deposited to borrow against'
 *
 * @category Errors
 * @category generated
 */
export class InsufficientCollateralError extends Error {
  readonly code: number = 0x1776
  readonly name: string = 'InsufficientCollateral'
  constructor() {
    super('there is not enough collateral deposited to borrow against')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InsufficientCollateralError)
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new InsufficientCollateralError())
createErrorFromNameLookup.set(
  'InsufficientCollateral',
  () => new InsufficientCollateralError(),
)

/**
 * SimultaneousDepositAndBorrow: 'cannot both deposit collateral to and borrow from the same reserve'
 *
 * @category Errors
 * @category generated
 */
export class SimultaneousDepositAndBorrowError extends Error {
  readonly code: number = 0x1777
  readonly name: string = 'SimultaneousDepositAndBorrow'
  constructor() {
    super('cannot both deposit collateral to and borrow from the same reserve')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SimultaneousDepositAndBorrowError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1777,
  () => new SimultaneousDepositAndBorrowError(),
)
createErrorFromNameLookup.set(
  'SimultaneousDepositAndBorrow',
  () => new SimultaneousDepositAndBorrowError(),
)

/**
 * ObligationHealthy: 'cannot liquidate a healthy position'
 *
 * @category Errors
 * @category generated
 */
export class ObligationHealthyError extends Error {
  readonly code: number = 0x1778
  readonly name: string = 'ObligationHealthy'
  constructor() {
    super('cannot liquidate a healthy position')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ObligationHealthyError)
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new ObligationHealthyError())
createErrorFromNameLookup.set(
  'ObligationHealthy',
  () => new ObligationHealthyError(),
)

/**
 * ObligationUnhealthy: 'cannot perform an action that would leave the obligation unhealthy'
 *
 * @category Errors
 * @category generated
 */
export class ObligationUnhealthyError extends Error {
  readonly code: number = 0x1779
  readonly name: string = 'ObligationUnhealthy'
  constructor() {
    super('cannot perform an action that would leave the obligation unhealthy')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ObligationUnhealthyError)
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new ObligationUnhealthyError())
createErrorFromNameLookup.set(
  'ObligationUnhealthy',
  () => new ObligationUnhealthyError(),
)

/**
 * ExceptionalReserveState: 'reserve requires special action; call refresh_reserve until up to date'
 *
 * @category Errors
 * @category generated
 */
export class ExceptionalReserveStateError extends Error {
  readonly code: number = 0x177a
  readonly name: string = 'ExceptionalReserveState'
  constructor() {
    super(
      'reserve requires special action; call refresh_reserve until up to date',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExceptionalReserveStateError)
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new ExceptionalReserveStateError())
createErrorFromNameLookup.set(
  'ExceptionalReserveState',
  () => new ExceptionalReserveStateError(),
)

/**
 * InvalidAmountUnits: 'the units provided in the amount are not valid for the instruction'
 *
 * @category Errors
 * @category generated
 */
export class InvalidAmountUnitsError extends Error {
  readonly code: number = 0x177b
  readonly name: string = 'InvalidAmountUnits'
  constructor() {
    super('the units provided in the amount are not valid for the instruction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidAmountUnitsError)
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new InvalidAmountUnitsError())
createErrorFromNameLookup.set(
  'InvalidAmountUnits',
  () => new InvalidAmountUnitsError(),
)

/**
 * InvalidDexMarketMints: 'the tokens in the DEX market don't match the reserve and lending market quote token'
 *
 * @category Errors
 * @category generated
 */
export class InvalidDexMarketMintsError extends Error {
  readonly code: number = 0x177c
  readonly name: string = 'InvalidDexMarketMints'
  constructor() {
    super(
      "the tokens in the DEX market don't match the reserve and lending market quote token",
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidDexMarketMintsError)
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new InvalidDexMarketMintsError())
createErrorFromNameLookup.set(
  'InvalidDexMarketMints',
  () => new InvalidDexMarketMintsError(),
)

/**
 * InvalidMarketAuthority: 'the market authority provided doesn't match the market account'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMarketAuthorityError extends Error {
  readonly code: number = 0x177d
  readonly name: string = 'InvalidMarketAuthority'
  constructor() {
    super("the market authority provided doesn't match the market account")
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMarketAuthorityError)
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new InvalidMarketAuthorityError())
createErrorFromNameLookup.set(
  'InvalidMarketAuthority',
  () => new InvalidMarketAuthorityError(),
)

/**
 * InvalidLiquidationQuoteTokenAccount: 'the quote token account provided cannot be used for liquidations'
 *
 * @category Errors
 * @category generated
 */
export class InvalidLiquidationQuoteTokenAccountError extends Error {
  readonly code: number = 0x177e
  readonly name: string = 'InvalidLiquidationQuoteTokenAccount'
  constructor() {
    super('the quote token account provided cannot be used for liquidations')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidLiquidationQuoteTokenAccountError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x177e,
  () => new InvalidLiquidationQuoteTokenAccountError(),
)
createErrorFromNameLookup.set(
  'InvalidLiquidationQuoteTokenAccount',
  () => new InvalidLiquidationQuoteTokenAccountError(),
)

/**
 * ObligationAccountMismatch: 'the obligation account doesn't have the collateral/loan registered'
 *
 * @category Errors
 * @category generated
 */
export class ObligationAccountMismatchError extends Error {
  readonly code: number = 0x177f
  readonly name: string = 'ObligationAccountMismatch'
  constructor() {
    super("the obligation account doesn't have the collateral/loan registered")
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ObligationAccountMismatchError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x177f,
  () => new ObligationAccountMismatchError(),
)
createErrorFromNameLookup.set(
  'ObligationAccountMismatch',
  () => new ObligationAccountMismatchError(),
)

/**
 * UnknownInstruction: 'unknown instruction'
 *
 * @category Errors
 * @category generated
 */
export class UnknownInstructionError extends Error {
  readonly code: number = 0x1780
  readonly name: string = 'UnknownInstruction'
  constructor() {
    super('unknown instruction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnknownInstructionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new UnknownInstructionError())
createErrorFromNameLookup.set(
  'UnknownInstruction',
  () => new UnknownInstructionError(),
)

/**
 * Disallowed: 'current conditions prevent an action from being performed'
 *
 * @category Errors
 * @category generated
 */
export class DisallowedError extends Error {
  readonly code: number = 0x1781
  readonly name: string = 'Disallowed'
  constructor() {
    super('current conditions prevent an action from being performed')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DisallowedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1781, () => new DisallowedError())
createErrorFromNameLookup.set('Disallowed', () => new DisallowedError())

/**
 * LiquidationSwapSlipped: 'the actual slipped amount on the DEX trade exceeded the threshold configured'
 *
 * @category Errors
 * @category generated
 */
export class LiquidationSwapSlippedError extends Error {
  readonly code: number = 0x1782
  readonly name: string = 'LiquidationSwapSlipped'
  constructor() {
    super(
      'the actual slipped amount on the DEX trade exceeded the threshold configured',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, LiquidationSwapSlippedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1782, () => new LiquidationSwapSlippedError())
createErrorFromNameLookup.set(
  'LiquidationSwapSlipped',
  () => new LiquidationSwapSlippedError(),
)

/**
 * CollateralValueTooSmall: 'the collateral value is too small for a DEX trade'
 *
 * @category Errors
 * @category generated
 */
export class CollateralValueTooSmallError extends Error {
  readonly code: number = 0x1783
  readonly name: string = 'CollateralValueTooSmall'
  constructor() {
    super('the collateral value is too small for a DEX trade')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollateralValueTooSmallError)
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new CollateralValueTooSmallError())
createErrorFromNameLookup.set(
  'CollateralValueTooSmall',
  () => new CollateralValueTooSmallError(),
)

/**
 * LiquidationLowCollateral: 'the collateral returned by the liquidation is smaller than requested'
 *
 * @category Errors
 * @category generated
 */
export class LiquidationLowCollateralError extends Error {
  readonly code: number = 0x1784
  readonly name: string = 'LiquidationLowCollateral'
  constructor() {
    super(
      'the collateral returned by the liquidation is smaller than requested',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, LiquidationLowCollateralError)
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new LiquidationLowCollateralError())
createErrorFromNameLookup.set(
  'LiquidationLowCollateral',
  () => new LiquidationLowCollateralError(),
)

/**
 * NotSupported: 'this action is currently not supported by this version of the program'
 *
 * @category Errors
 * @category generated
 */
export class NotSupportedError extends Error {
  readonly code: number = 0x1785
  readonly name: string = 'NotSupported'
  constructor() {
    super(
      'this action is currently not supported by this version of the program',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotSupportedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new NotSupportedError())
createErrorFromNameLookup.set('NotSupported', () => new NotSupportedError())

/**
 * MarketHalted: 'the market has currently halted this kind of operation'
 *
 * @category Errors
 * @category generated
 */
export class MarketHaltedError extends Error {
  readonly code: number = 0x1786
  readonly name: string = 'MarketHalted'
  constructor() {
    super('the market has currently halted this kind of operation')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MarketHaltedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1786, () => new MarketHaltedError())
createErrorFromNameLookup.set('MarketHalted', () => new MarketHaltedError())

/**
 * InvalidParameter: 'a given parameter is not valid'
 *
 * @category Errors
 * @category generated
 */
export class InvalidParameterError extends Error {
  readonly code: number = 0x1787
  readonly name: string = 'InvalidParameter'
  constructor() {
    super('a given parameter is not valid')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidParameterError)
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new InvalidParameterError())
createErrorFromNameLookup.set(
  'InvalidParameter',
  () => new InvalidParameterError(),
)

/**
 * PositionNotEmpty: 'the obligation account still holds position in the loan or collateral account'
 *
 * @category Errors
 * @category generated
 */
export class PositionNotEmptyError extends Error {
  readonly code: number = 0x1788
  readonly name: string = 'PositionNotEmpty'
  constructor() {
    super(
      'the obligation account still holds position in the loan or collateral account',
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PositionNotEmptyError)
    }
  }
}

createErrorFromCodeLookup.set(0x1788, () => new PositionNotEmptyError())
createErrorFromNameLookup.set(
  'PositionNotEmpty',
  () => new PositionNotEmptyError(),
)

/**
 * ObligationPositionNotFound: 'position not found in an obligation'
 *
 * @category Errors
 * @category generated
 */
export class ObligationPositionNotFoundError extends Error {
  readonly code: number = 0x1789
  readonly name: string = 'ObligationPositionNotFound'
  constructor() {
    super('position not found in an obligation')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ObligationPositionNotFoundError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1789,
  () => new ObligationPositionNotFoundError(),
)
createErrorFromNameLookup.set(
  'ObligationPositionNotFound',
  () => new ObligationPositionNotFoundError(),
)

/**
 * AccountNotEmptyError: 'the collateral/loan account is not empty'
 *
 * @category Errors
 * @category generated
 */
export class AccountNotEmptyErrorError extends Error {
  readonly code: number = 0x178a
  readonly name: string = 'AccountNotEmptyError'
  constructor() {
    super('the collateral/loan account is not empty')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountNotEmptyErrorError)
    }
  }
}

createErrorFromCodeLookup.set(0x178a, () => new AccountNotEmptyErrorError())
createErrorFromNameLookup.set(
  'AccountNotEmptyError',
  () => new AccountNotEmptyErrorError(),
)

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
